// Did this code successfully run on Leetcode : yes
// Any problem you faced while coding this : figuring out the DFS solution i.e. how to apply DSU via DFS (coloring groups)
// LC: 924

import java.util.*;

public class MinimizeMalwareSpread {

    /**
     * If more than 1 initial nodes are part of a single connected component, it means we cannot save that component.
     * <p>
     * So, find affected components with initial count as 1.
     * <p>
     * Among those, consider the max size component.
     * <p>
     * if multiple max sizes, consider the smallest among ans initial.
     * <p>
     * if not possible, return the smallest among all initial.
     * <p>
     * This implies go for DSU.
     * Unionize the graph.
     * <p>
     * TC: O(n^2)
     * SC: O(n)
     *
     * @param graph
     * @param initial
     * @return
     */
    public int minMalwareSpread_dsu(int[][] graph, int[] initial) {
        int n = graph.length;
        DSU dsu = new DSU();
        // Unionize the graph
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (graph[i][j] == 1) {
                    dsu.union(i, j);
                }
            }
        }

        // get initial's parents and increment the count for multiple occurrences
        Map<Integer, Integer> initialInfectedParents = new HashMap<>();
        for (int i : initial) {
            int initialInfectedParent = dsu.findParent(i);
//            if (!initialInfectedParents.containsKey(initialInfectedParent)) {
//                initialInfectedParents.put(initialInfectedParent, 0);
//            }
            initialInfectedParents.putIfAbsent(initialInfectedParent, 0);
//            int count = initialInfectedParents.get(initialInfectedParent);
//            initialInfectedParents.put(initialInfectedParent, count + 1);
            initialInfectedParents.compute(initialInfectedParent, (k, count) -> count + 1);
        }

        int maxSize = 0;
        int ans = n + 1;
        int minInitial = initial[0];
        for (int i : initial) {
            minInitial = Math.min(minInitial, i);
            int initialInfectedParent = dsu.findParent(i);
            // for infected parents occurring once in the map, consider as probable answer.
            if (initialInfectedParents.getOrDefault(initialInfectedParent, 0) == 1) {
                int size = dsu.getSize(initialInfectedParent);
                if (size > maxSize) {
                    maxSize = size;
                    ans = i;
                } else if (size == maxSize) {
                    ans = Math.min(ans, i);
                }
            }
        }
        return ans > n ? minInitial : ans;
    }

    /**
     * Apply DSU via coloring the nodes is a connected component using DFS.
     * <p>
     * # of unique colors used == # of ultimate parents in DSU
     * <p>
     * find group size by coloring the node with the group color == node visited
     * <p>
     * TC: O(n^2)
     * SC: O(n)
     *
     * @param graph
     * @param initial
     * @return
     */
    public int minMalwareSpread_dfs(int[][] graph, int[] initial) {
        int n = graph.length;
        int color = 0;
        int[] visited = new int[n];
        Arrays.fill(visited, -1);
        // color the graph == connect the nodes
        for (int i = 0; i < n; i++) {
            if (visited[i] == -1) {
                dfs(i, color, graph, visited);
                color++;
            }
        }
        // component size
        int[] sizes = new int[color];
        for (int i : visited) {
            sizes[i]++;
        }
        // initial's parent count
        int[] infectedParentsCount = new int[color];
        for (int i : initial) {
            int parent = visited[i];
            infectedParentsCount[parent]++;
        }
        // calculate answer
        int maxSize = 0;
        int ans = -1;
        int min = n;
        for (int i : initial) {
            min = Math.min(min, i);
            int parent = visited[i];
            if (infectedParentsCount[parent] == 1) {
                int size = sizes[parent];
                if (size > maxSize) {
                    maxSize = size;
                    ans = i;
                } else if (size == maxSize) {
                    ans = Math.min(ans, i);
                }
            }
        }
        return ans == -1 ? min : ans;
    }

    private void dfs(int node, int color, int[][] graph, int[] visited) {
        visited[node] = color;
        int n = graph.length;
        for (int adj = 0; adj < n; adj++) {
            if (graph[node][adj] == 1) {
                if (visited[adj] == -1) {
                    dfs(adj, color, graph, visited);
                }
            }
        }
    }

}

class DSU {
    Map<Integer, Integer> parents;
    Map<Integer, Integer> sizes;

    DSU() {
        parents = new HashMap<>();
        sizes = new HashMap<>();
    }

    int findParent(int node) {
        if (!parents.containsKey(node)) {
            parents.put(node, node);
            sizes.put(node, 1);
            return node;
        }
        int parent = parents.get(node);
        if (parent == node) {
            return node;
        }
        return findParent(parent);
    }

    void union(int u, int v) {
        int pU = findParent(u);
        int pV = findParent(v);
        // already connected
        if (pV == pU) {
            return;
        }
        int sizePU = sizes.get(pU);
        int sizePV = sizes.get(pV);

        if (sizePU >= sizePV) {
            // connect v to u
            parents.put(pV, pU);
            sizes.put(pU, sizePV + sizePU);
        } else {
            // connect u to v
            parents.put(pU, pV);
            sizes.put(pV, sizePV + sizePU);
        }
    }

    int getSize(int node) {
        return sizes.get(node);
    }
}
